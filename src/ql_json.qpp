/* -*- mode: c++; indent-tabs-mode: nil -*- */
/** @file ql_json.qpp defines JSON functions */
/*
    lib/ql_json.qpp

    Qore JSON (JavaScript QoreObject Notation) functions

    Qore Programming Language

    Copyright 2003 - 2018 Qore Technologies, s.r.o.

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "qore-json-module.h"

#include "ql_json.h"

#include <ctype.h>
#include <stdlib.h>
#include <cmath>

// RFC 4627 JSON specification
// qore only supports JSON with UTF-8

// returns 0 for OK
static int cmp_rest_token(const char*& p, const char* tok) {
   p++;
   while (*tok)
      if ((*(p++)) != (*(tok++)))
         return -1;
   if (!*p || *p == ',' || *p == ']' || *p == '}')
      return 0;
   if (isblank(*p) || (*p) == '\r' || (*p) == '\n') {
      ++p;
      return 0;
   }
   return -1;
}

static void skip_whitespace(const char*& buf, int& line_number) {
   while (*buf) {
      if (isblank(*buf) || (*buf) == '\r') {
         ++buf;
         continue;
      }
      if ((*buf) == '\n') {
         ++line_number;
         ++buf;
         continue;
      }
      break;
   }
}

// '"' has already been read and the buffer is set to this character
static int get_json_string_token(QoreString& str, const char*& buf, int& line_number, ExceptionSink* xsink) {
   // increment buffer to first character of string
   buf++;
   while (*buf) {
      if (*buf == '"') {
         buf++;
         return 0;
      }
      if (*buf == '\\') {
         buf++;
         if (*buf == '"' || *buf == '/' || *buf == '\\') {
            str.concat(*buf);
            buf++;
            continue;
         }
         if (*buf == 'a')
            str.concat('\a');
         else if (*buf == 'b')
            str.concat('\b');
         else if (*buf == 'f')
            str.concat('\f');
         else if (*buf == 'n')
            str.concat('\n');
         else if (*buf == 'r')
            str.concat('\r');
         else if (*buf == 't')
            str.concat('\t');
         else if (*buf == 'v')
            str.concat('\v');
         else if (*buf == 'u') { // expect a unicode character specification
            ++buf;
            // check for 4 hex digits
            if (isxdigit(*buf) && isxdigit(*(buf + 1)) && isxdigit(*(buf + 2)) && isxdigit(*(buf + 3))) {
               char unicode[5];
               strncpy(unicode, buf, 4);
               unicode[4] = '\0';
               unsigned code = strtoul(unicode, 0, 16);
               if (str.concatUnicode(code, xsink))
                  break;
               buf += 3;
            }
            else
               str.concat("\\u");
         }
         else { // otherwise just concatenate the characters
            str.concat('\\');
            str.concat(*buf);
         }
         ++buf;
         continue;
      }
      if (*buf == '\n')
         line_number++;
      str.concat(*buf);
      ++buf;
   }
   xsink->raiseException("JSON-PARSE-ERROR", "premature end of input at line %d while parsing JSON string", line_number);
   return -1;
}

static QoreValue get_json_value(const char*& buf, int& line_number, const QoreEncoding* enc, ExceptionSink* xsink);

// '{' has already been read and the buffer is set to this character
static QoreHashNode* get_json_object(const char*& buf, int& line_number, const QoreEncoding* enc, ExceptionSink* xsink) {
    // increment buffer to first character of object description
    buf++;
    ReferenceHolder<QoreHashNode> h(new QoreHashNode, xsink);

    // get either string or '}'
    skip_whitespace(buf, line_number);

    if (*buf == '}') {
        buf++;
        return h.release();
    }

    while (*buf) {
        if (*buf != '"') {
            //printd(5, "*buf='%c'\n", *buf);
            if (h->size())
                xsink->raiseException("JSON-PARSE-ERROR", "unexpected text encountered at line %d while parsing JSON object (expecting '\"' for key string)", line_number);
            else
                xsink->raiseException("JSON-PARSE-ERROR", "unexpected text encountered at line %d while parsing JSON object (expecting '\" or '}'')", line_number);
            break;
        }

        // get key
        QoreString str(enc);
        if (get_json_string_token(str, buf, line_number, xsink))
            break;

        //printd(5, "get_json_object() key=%s\n", str.getBuffer());

        skip_whitespace(buf, line_number);
        if (*buf != ':') {
            //printd(5, "*buf='%c'\n", *buf);
            xsink->raiseException("JSON-PARSE-ERROR", "unexpected text encountered at line %d while parsing JSON object (expecting ':')", line_number);
            break;
        }
        buf++;
        skip_whitespace(buf, line_number);

        // get value
        QoreValue val = get_json_value(buf, line_number, enc, xsink);
        if (*xsink) {
            break;
        }
        h->setKeyValue(&str, val, xsink);

        skip_whitespace(buf, line_number);
        if (*buf == '}') {
            buf++;
            return h.release();
        }

        if (*buf != ',') {
            xsink->raiseException("JSON-PARSE-ERROR", "unexpected text encountered at line %d while parsing JSON object (expecting ',' or '}')", line_number);
            break;
        }
        buf++;

        skip_whitespace(buf, line_number);

    }
    return 0;
}

// '[' has already been read and the buffer is set to this character
static AbstractQoreNode* get_json_array(const char*& buf, int& line_number, const QoreEncoding* enc, ExceptionSink* xsink) {
    // increment buffer to first character of array description
    buf++;
    ReferenceHolder<QoreListNode> l(new QoreListNode, xsink);

    skip_whitespace(buf, line_number);
    if (*buf == ']') {
        ++buf;
        return l.release();
    }

    while (*buf) {
        //printd(5, "before get_json_value() buf=%s\n", buf);
        QoreValue val = get_json_value(buf, line_number, enc, xsink);
        if (!val) {
            if (!xsink->isException())
                xsink->raiseException("JSON-PARSE-ERROR", "premature end of input at line %d while parsing JSON array (expecting JSON value)", line_number);
            return 0;
        }
        //printd(5, "after get_json_value() buf=%s\n", buf);
        l->push(val, xsink);

        skip_whitespace(buf, line_number);
        if (*buf == ']') {
            buf++;
            return l.release();
        }

        if (*buf != ',') {
            //printd(5, "*buf='%c'\n", *buf);
            xsink->raiseException("JSON-PARSE-ERROR", "unexpected text encountered at line %d while parsing JSON array (expecting ',' or ']')", line_number);
            return 0;
        }
        buf++;

        skip_whitespace(buf, line_number);
    }
    return 0;
}

static QoreValue get_json_value(const char*& buf, int& line_number, const QoreEncoding* enc, ExceptionSink* xsink) {
    // skip whitespace
    skip_whitespace(buf, line_number);
    if (!*buf)
        return QoreValue();

    // can expect: 't'rue, 'f'alse, '{', '[', '"'string...", integer, '.'digits
    if (*buf == '{')
        return get_json_object(buf, line_number, enc, xsink);

    if (*buf == '[')
        return get_json_array(buf, line_number, enc, xsink);

    if (*buf == '"') {
        QoreStringNodeHolder str(new QoreStringNode(enc));
        return get_json_string_token(*(*str), buf, line_number, xsink) ? 0 : str.release();
    }

    // FIXME: implement parsing of JSON exponents
    if (isdigit(*buf) || (*buf) == '.' || (*buf) == '-') {
        // temporarily use a QoreString
        QoreString str;
        bool has_dot;
        if (*buf == '.') {
            // add a leading zero
            str.concat("0.");
            has_dot = true;
        }
        else {
            str.concat(*buf);
            has_dot = false;
        }
        buf++;
        while (*buf) {
            if (*buf == '.') {
                if (has_dot) {
                    xsink->raiseException("JSON-PARSE-ERROR", "unexpected '.' in floating point number (too many '.' characters)");
                    return 0;
                }
                has_dot = true;
            }
            // if another token follows then break but do not increment buffer position
            else if (*buf == ',' || *buf == '}' || *buf == ']')
                break;
            // if whitespace follows then increment buffer position and break
            else if (isblank(*buf) || (*buf) == '\r') {
                ++buf;
                break;
            }
            // if a newline follows then  increment buffer position and line number and break
            else if ((*buf) == '\n') {
                ++buf;
                ++line_number;
                break;
            }
            else if (!isdigit(*buf)) {
                xsink->raiseException("JSON-PARSE-ERROR", "unexpected character in number");
                return QoreValue();
            }
            str.concat(*buf);
            buf++;
        }
        if (has_dot)
            return strtod(str.getBuffer(), 0);
        return strtoll(str.getBuffer(), 0, 10);
    }

    if ((*buf) == 't') {
        if (!cmp_rest_token(buf, "rue"))
            return true;
    }
    else if ((*buf) == 'f') {
        if (!cmp_rest_token(buf, "alse"))
            return false;
    }
    else if ((*buf) == 'n') {
        if (!cmp_rest_token(buf, "ull"))
            return nothing();
    }
    //printd(5, "buf=%s\n", buf);

    xsink->raiseException("JSON-PARSE-ERROR", "invalid input at line %d; unable to parse JSON value", line_number);
    return QoreValue();
}

#define JSF_THRESHOLD 20

static int do_json_value(QoreString* str, QoreValue v, int format, ExceptionSink* xsink);

static int do_json_list(ExceptionSink* xsink, QoreString* str, const QoreListNode* l, int format, unsigned offset = 0) {
    assert(l);
    str->concat("[");
    ConstListIterator li(l);
    QoreString tmp(str->getEncoding());
    while (li.next()) {
        if (li.index() < offset)
            continue;
        bool ind = tmp.strlen() > JSF_THRESHOLD;
        tmp.clear();
        if (do_json_value(&tmp, li.getValue(), format == -1 ? format : format + 2, xsink))
            return -1;

        if (format != -1 && (ind || tmp.strlen() > JSF_THRESHOLD)) {
            str->concat('\n');
            str->addch(' ', format + 2);
        }
        str->sprintf("%s", tmp.getBuffer());

        if (!li.last())
            str->concat(",");
    }
    str->concat("]");
    return 0;
}

static int do_json_string_intern(ExceptionSink* xsink, QoreString* str, const char* utf8_str, int format) {
   str->concat('"');
   qore_size_t i = str->size();
   str->concatEscape(utf8_str, '"', '\\');

   // http://tools.ietf.org/html/rfc4627
   // encode all control characters in the string concatenated
   while (i < str->size()) {
      // see if we have a single-byte character; do not try to look at bytes within multi-byte characters
      qore_size_t cl = q_get_char_len(str->getEncoding(), str->getBuffer() + i, str->size() - i, xsink);
      if (*xsink)
         return -1;
      if (cl > 1) {
         i += cl;
         continue;
      }

      unsigned char c = (*str)[i];
      if (c < 32) {
         switch (c) {
            case 7: str->replace(i, 1, "\\a"); ++i; break; // BEL
            case 8: str->replace(i, 1, "\\b"); ++i; break; // BS
            case 9: str->replace(i, 1, "\\t"); ++i; break; // HT
            case 10: str->replace(i, 1, "\\n"); ++i; break; // LF
            case 11: str->replace(i, 1, "\\v"); ++i; break; // VT
            case 12: str->replace(i, 1, "\\f"); ++i; break; // FF
            case 13: str->replace(i, 1, "\\r"); ++i; break; // CR
            default: {
               char buf[7];
               sprintf(buf, "\\u%04x", (int)c);
               str->replace(i, 1, buf); i += 5;
               break;
            }
         }
      }
      ++i;
   }

   str->concat('"');
   return 0;
}

static int do_json_string(ExceptionSink* xsink, QoreString* str, const QoreString* vstr, int format) {
   TempEncodingHelper t(vstr, str->getEncoding(), xsink);
   if (*xsink)
      return -1;

   return do_json_string_intern(xsink, str, t->c_str(), format);
}

static int do_json_value(QoreString* str, QoreValue v, int format, ExceptionSink* xsink) {
   if (v.isNullOrNothing()) {
      str->concat("null");
      return 0;
   }

   qore_type_t vtype = v.getType();

   if (vtype == NT_LIST)
      return do_json_list(xsink, str, v.get<const QoreListNode>(), format);

   if (vtype == NT_HASH) {
      const QoreHashNode* h = v.get<const QoreHashNode>();
      str->concat("{");
      ConstHashIterator hi(h);
      QoreString tmp(str->getEncoding());
      while (hi.next()) {
         bool ind = tmp.strlen() > JSF_THRESHOLD;
         tmp.clear();
         if (do_json_value(&tmp, hi.get(), format == -1 ? format : format + 2, xsink))
            return -1;

         if (format != -1 && (ind || tmp.strlen() > JSF_THRESHOLD)) {
            str->concat('\n');
            str->addch(' ', format + 2);
         }

         QoreString tmpkey(hi.getKey());
         if (do_json_string(xsink, str, &tmpkey, format))
            return -1;
         str->concat(": ");
         str->concat(tmp.c_str(), tmp.size());
         //str->sprintf("\"%s\": %s", hi.getKey(), tmp.getBuffer());
         if (!hi.last())
            str->concat(",");

      }
      str->concat("}");
      return 0;
   }
/*
   if (vtype == NT_STRING) {
      const QoreStringNode* vstr = v.get<const QoreStringNode>();

      TempEncodingHelper t(vstr, str->getEncoding(), xsink);
      if (*xsink)
         return -1;

      str->concat('"');
      qore_size_t i = str->size();
      str->concatEscape(*t, '"', '\\', xsink);
      if (*xsink)
         return -1;

      // http://tools.ietf.org/html/rfc4627
      // encode all control characters in the string concatenated
      while (i < str->size()) {
         // see if we have a single-byte character; do not try to look at bytes within multi-byte characters
         qore_size_t cl = q_get_char_len(str->getEncoding(), str->getBuffer() + i, str->size() - i, xsink);
         if (*xsink)
            return -1;

         if (format != -1 && (ind || tmp.strlen() > JSF_THRESHOLD)) {
            str->concat('\n');
            str->addch(' ', format + 2);
         }
         str->sprintf("\"%s\": %s", hi.getKey(), tmp.getBuffer());
         if (!hi.last())
            str->concat(",");
      }
      str->concat("}");
      return 0;
   }
*/

   if (vtype == NT_STRING)
      return do_json_string(xsink, str, v.get<const QoreStringNode>(), format);

   if (vtype == NT_INT) {
      str->sprintf("%lld", v.getAsBigInt());
      return 0;
   }

   if (vtype == NT_FLOAT) {
      double f = v.getAsFloat();
      // check for nan, +/-inf and serialize as null
      if (std::isnan(f) || std::isinf(f))
         str->concat("null");
      else
         str->sprintf("%.20g", f);
      return 0;
   }

   if (vtype == NT_NUMBER) {
      const QoreNumberNode* n = v.get<const QoreNumberNode>();
      if (!n->ordinary())
         str->concat("null");
      else
         n->getStringRepresentation(*str);
      return 0;
   }

   if (vtype == NT_BOOLEAN) {
      str->concat(v.getAsBool() ? "true" : "false");
      return 0;
   }

   if (vtype == NT_DATE) {
      const DateTimeNode* date = v.get<const DateTimeNode>();
      // this will be serialized as a string
      str->concat('"');
#ifndef SECS_PER_MINUTE
#define SECS_PER_MINUTE          60
#endif
#ifndef SECS_PER_HOUR
#define SECS_PER_HOUR            (SECS_PER_MINUTE * 60)
#endif
      // ensure that all date/time values are reported in the current time zone
      // for simplicity's sake (particularly because json does not have a native date/time format)
      qore_tm info;
      date->getInfo(currentTZ(), info);
      // issue #2655 include a 'T' between the date and time as per ISO-8601
      str->sprintf("%04d-%02d-%02dT%02d:%02d:%02d.%06d", info.year, info.month, info.day, info.hour, info.minute, info.second, info.us);
      if (!info.utc_secs_east)
         str->concat('Z');
      else {
         // issue #2655 do not include a space before the UTC offset
         str->concat(info.utc_secs_east < 0 ? '-' : '+');
         if (info.utc_secs_east < 0)
            info.utc_secs_east = -info.utc_secs_east;
         int h = info.utc_secs_east / SECS_PER_HOUR;
         // the remaining seconds after hours
         int r = info.utc_secs_east % SECS_PER_HOUR;
         // minutes
         int m = r / SECS_PER_MINUTE;
         // we have already output the hour sign above
         str->sprintf("%02d:%02d", h < 0 ? -h : h, m);
         // see if there are any seconds
         int s = info.utc_secs_east - h * SECS_PER_HOUR - m * SECS_PER_MINUTE;
         if (s)
            str->sprintf(":%02d", s);
      }
      str->concat('"');
      return 0;
   }

   if (vtype == NT_BINARY) {
      str->concat('\"');
      str->concatBase64(v.get<const BinaryNode>());
      str->concat('\"');
      return 0;
   }

   xsink->raiseException("JSON-SERIALIZATION-ERROR", "don't know how to serialize type '%s'", v.getTypeName());
   return -1;
}

QoreStringNode* make_jsonrpc_request_args(const std::string& version, const QoreListNode* args, QoreValue id, unsigned offset, ExceptionSink* xsink) {
   const QoreStringNode* p0 = HARD_QORE_VALUE_STRING(args, offset);

   const QoreValue p1 = get_param_value(args, offset + 1);

   QoreStringNodeHolder str(new QoreStringNode(QCS_UTF8));

   // write version key first
   if (version == "1.0")
      str->concat("{\"method\": ");
   else
      str->sprintf("{\"%s\": \"%s\",\"method\": ", version[0] == '1' ? "version" : "jsonrpc", version.c_str());
   if (do_json_value(*str, p0, -1, xsink))
      return 0;

   if (!id.isNullOrNothing()) {
      str->concat(",\"id\": ");
      if (do_json_value(*str, id, -1, xsink))
         return 0;
   }

   // params key should come last
   str->concat(",\"params\": ");
   if (!p1.isNullOrNothing()) {
      if (do_json_value(*str, p1, -1, xsink))
         return 0;
   }
   else
      str->concat("null");
   str->concat("}");
   return str.release();
}

QoreStringNode* make_jsonrpc_request(const std::string& version, const QoreListNode* args, QoreValue id, unsigned offset, ExceptionSink* xsink) {
   const QoreStringNode* p0 = HARD_QORE_VALUE_STRING(args, offset);

   QoreStringNodeHolder str(new QoreStringNode(QCS_UTF8));

   // write version key first
   if (version == "1.0")
      str->concat("{\"method\": ");
   else
      str->sprintf("{\"%s\": \"%s\",\"method\": ", version[0] == '1' ? "version" : "jsonrpc", version.c_str());
   if (do_json_value(*str, p0, -1, xsink))
      return 0;

   if (!id.isNullOrNothing()) {
      str->concat(",\"id\": ");
      if (do_json_value(*str, id, -1, xsink))
         return 0;
   }

   // params key should come last
   str->concat(",\"params\" : ");
   if (num_args(args) > (offset + 1)) {
      if (do_json_list(xsink, *str, args, 0, offset + 1))
         return 0;
   }
   else
      str->concat("null");
   str->concat("}");

   return str.release();
}

QoreValue parse_json(const QoreString* str, ExceptionSink* xsink) {
    int line_number = 1;
    const char* buf = str->getBuffer();
    const unsigned char* data = reinterpret_cast<const unsigned char*>(buf);
    if (str->size() >= 3 && data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) { // Skip UTF-8 BOM.
        buf = reinterpret_cast<const char*>(data+3);
    }
    else if (str->size() >= 2) { // Skip Unicode BOM.
        if ((data[0] == 0xFE && data[1] == 0xFF) || (data[0] == 0xFF && data[1] == 0xFE)) {
            buf = reinterpret_cast<const char*>(data+2);
        }
    }

    ValueHolder rv(get_json_value(buf, line_number, str->getEncoding(), xsink), xsink);
    if (rv && *buf) {
        // check for excess text after JSON data
        skip_whitespace(buf, line_number);
        if (*buf) {
            xsink->raiseException("JSON-PARSE-ERROR", "extra text after JSON data on line %d", line_number);
            return QoreValue();
        }
    }
    return rv.release();
}

// for JSON-RPC 1.1, version_name = "version"; for 2.0, version_name = "jsonrpc"
static QoreStringNode* make_jsonrpc_request(const QoreStringNode* method_name, const char* version_name, const char* version, QoreValue id, QoreValue request_msg, int format, ExceptionSink* xsink) {
   QoreStringNodeHolder str(new QoreStringNode(QCS_UTF8));

   bool fmt = format & JGF_ADD_FORMATTING;

   // write version key first if present
   if (version && *version) {
      str->sprintf("{%s\"%s\" : ", fmt ? "\n  " : "", version_name);
      if (do_json_string_intern(xsink, *str, version, fmt ? 2 : -1))
         return 0;
      str->concat(fmt ? ",\n  " : ",");
   }
   else
      str->concat(fmt ? "{\n  " : "{");

   str->concat("\"method\": ");
   if (do_json_value(*str, method_name, fmt ? 2 : -1, xsink))
      return 0;

   if (!id.isNullOrNothing()) {
      str->sprintf(",%s\"id\": ", fmt ? "\n  " : "");
      if (do_json_value(*str, id, fmt ? 2 : -1, xsink))
         return 0;
   }

   // params key should come last
   str->sprintf(",%s\"params\": ", fmt ? "\n  " : "");
   if (do_json_value(*str, request_msg, fmt ? 2 : -1, xsink))
      return 0;

   str->concat(fmt ? "\n}" : "}");
   return str.release();
}

// for JSON-RPC 1.1, version_name = "version"; for 2.0, version_name = "jsonrpc"
static QoreStringNode* make_jsonrpc_response(ExceptionSink* xsink, const char* version_name, const char* version, QoreValue id, QoreValue msg, const char* type = "result", int format = 0) {
   QoreStringNodeHolder str(new QoreStringNode(QCS_UTF8));

   bool fmt = format & JGF_ADD_FORMATTING;

   // write version key first if present
   if (version && *version) {
      str->sprintf("{%s\"%s\" : ", fmt ? "\n  " : "", version_name);
      if (do_json_string_intern(xsink, *str, version, fmt ? 2 : -1))
         return 0;
      str->concat(fmt ? ",\n  " : ",");
   }
   else
      str->concat(fmt ? "{\n  " : "{");

   if (!id.isNullOrNothing()) {
      str->concat("\"id\": ");
      if (do_json_value(*str, id, fmt ? 2 : -1, xsink))
         return 0;
      str->concat(fmt ? ",\n  " : ",");
   }

   // result/error key should come last
   str->sprintf("\"%s\": ", type);
   if (do_json_value(*str, msg, fmt ? 2 : -1, xsink))
      return 0;

   str->concat(fmt ? "\n}" : "}");
   return str.release();
}

static QoreStringNode* make_jsonrpc11_error(int64 code, const QoreStringNode* error, QoreValue id, QoreValue error_msg, int format, ExceptionSink* xsink) {
   if (code < 100 || code > 999) {
      xsink->raiseException("MAKE-JSONRPC11-ERROR-STRING-ERROR", "error code (first argument) must be between 100 and 999 inclusive (value passed: " QLLD ")", code);
      return 0;
   }

   if (error->empty()) {
      xsink->raiseException("MAKE-JSONRPC11-ERROR-STRING-ERROR", "empty error message string passed as second argument)");
      return 0;
   }

   QoreStringNodeHolder str(new QoreStringNode(QCS_UTF8));

   bool fmt = format & JGF_ADD_FORMATTING;

   str->concat(fmt ? "{\n  \"version\": \"1.1\",\n  " : "{\"version\": \"1.1\",");

   // get optional "id" value
   if (!id.isNullOrNothing()) {
      str->concat("\"id\": ");
      if (do_json_value(*str, id, fmt ? 2 : -1, xsink))
         return 0;
      str->concat(fmt ? ",\n  " : ",");
   }

   if (fmt)
      str->sprintf("\"error\":\n  {\n    \"name\": \"JSONRPCError\",\n    \"code\": %d,\n    \"message\": \"", (int)code);
   else
      str->sprintf("\"error\": {\"name\": \"JSONRPCError\",\"code\": %d,\"message\": \"", (int)code);
   // concat here so character encodings can be automatically converted if necessary
   str->concatEscape(error, '"', '\\', xsink);
   if (*xsink)
      return 0;

   str->concat('\"');

   // get optional "error" value
   if (!error_msg.isNullOrNothing()) {
      str->sprintf(",%s\"error\": ", fmt ? "\n   " : "");
      if (do_json_value(*str, error_msg, fmt ? 4 : -1, xsink))
         return 0;
   }
   str->concat(fmt ? "\n  }\n}" : "}}");
   return str.release();
}

/** @defgroup json_generation_constants JSON Generation Constants
    The constants in this group can be combined with @ref bitwise_or_operator "binary or" to affect the output of generated JSON
 */
//@{
namespace Qore::Json;

//! no flags; standard JSON generation without whitespace formatting
const JGF_NONE = JGF_NONE;

//! use whitespace formatting including line breaks and indentation to make generated JSON more readable by humans
const JGF_ADD_FORMATTING = JGF_ADD_FORMATTING;
//@}

/** @defgroup json_functions JSON Functions
 */
//@{
namespace Qore::Json;

//! Serializes qore data into a JSON string with optional whitespace formatting (line breaks and indentation)
/** @par Example:
    @code string json = make_json(data); @endcode

    By default the string produced will be in UTF-8 encoding, but this can be overridden by the \a encoding argument

    @param data the data to serialize to a JSON string
    @param format optional formatting flags; see @ref json_generation_constants for more information
    @param encoding an optional output encoding for the resulting JSON string; if this argument is not passed, then UTF-8 encoding is used by default

    @return the JSON string corresponding to the arguments passed

    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)
    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if an error occurs converting input strings to the target encoding

    @note According to <a href="https://tools.ietf.org/html/rfc7159">RFC 7159</a> JSON strings can only be in UTF-8, UTF-16, or UTF-32 encoding, but this function will allow any encoding to be used to generate JSON strings

    @see @ref jsonserialization

    @since json 1.5 as a replacement for deprecated camel-case makeJSONString() and makeFormattedJSONString()
*/
string make_json(any data, *int format, *string encoding) [flags=RET_VALUE_ONLY] {
   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_UTF8;
   QoreStringNodeHolder str(new QoreStringNode(qe));
   return do_json_value(*str, data, format & JGF_ADD_FORMATTING ? 0 : -1, xsink) ? 0 : str.release();
}

//! Serializes qore data into a JSON string, without any line breaks
/** By default the string produced will be in UTF-8 encoding, but this can be overridden by the second argument
    @param data the data to serialize to a JSON string
    @param encoding an optional output encoding for the resulting JSON string; if this argument is not passed, then UTF-8 encoding is used by default

    @return the JSON string corresponding to the arguments passed, without any line breaks

    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @deprecated use make_json(); camel-case function names were deprecated in json 1.5

    @see @ref jsonserialization
*/
string makeJSONString(any data, *string encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_UTF8;
   QoreStringNodeHolder str(new QoreStringNode(qe));
   return do_json_value(*str, data, -1, xsink) ? 0 : str.release();
}

//! Serializes qore data into a JSON string, formatted with line breaks for easier readability
/** By default the string produced will be in UTF-8 encoding, but this can be overridden by the second argument
    @param data the data to serialize to a JSON string
    @param encoding an optional output encoding for the resulting JSON string; if this argument is not passed, then UTF-8 encoding is used by default

    @return the JSON string corresponding to the arguments passed, formatted with line breaks for easier readability

    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @deprecated use make_json(); camel-case function names were deprecated in json 1.5

    @see @ref jsonserialization
*/
string makeFormattedJSONString(any data, *string encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_UTF8;
   QoreStringNodeHolder str(new QoreStringNode(qe));
   return do_json_value(*str, data, 0, xsink) ? 0 : str.release();
}

//! Parses a JSON string and returns the corresponding %Qore data structure
/** @param json_str the JSON string to parse

    @return the %Qore data structure corresponding to the input string

    @throw JSON-PARSE-ERROR syntax error parsing JSON string

    @par Example:
    @code any data = parse_json(json); @endcode

    @see @ref jsonserialization

    @since json 1.5 as a replacement for deprecated camel-case parseJSON()
 */
auto parse_json(string json_str) [flags=RET_VALUE_ONLY] {
   return parse_json(json_str, xsink);
}

//! This is a variant that is basically a noop, included for backwards-compatibility for functions that ignored type errors in the calling parameters
/**
 */
nothing parseJSON() [flags=RUNTIME_NOOP,DEPRECATED] {
}

//! Parses a JSON string and returns the corresponding %Qore data structure
/** @param json_str the JSON string to parse

    @return the %Qore data structure corresponding to the input string

    @throw JSON-PARSE-ERROR syntax error parsing JSON string

    @see @ref jsonserialization

    @deprecated use parse_json(); camel-case function names were deprecated in json 1.5
 */
auto parseJSON(string json_str) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return parse_json(json_str, xsink);
}
//@}

/** @defgroup json_rpc_functions JSON-RPC Functions
 */
//@{
//! Creates a JSON-RPC request string from the parameters passed, without any line breaks
/** To follow JSON-RPC specifications, the generated string will always be in UTF-8 encoding
    @param method_name the name of the JSON-RPC method to call
    @param version the JSON-RPC version to include in the call under the \c "version" key (for JSON-RPC earlier than 2.0) or the \c "jsonrpc" key (for JSON-RPC equal to or greater than 2.0); will be converted to a string; if the resulting string is empty, the \c "version" key will not be sent; note that for strict JSON-RPC 1.0 compatibility this argument will not be serialized if passed as \c "1.0"
    @param id the ID of the call
    @param request_msg the parameters for the message/message payload
    @param format optional formatting flags; see @ref json_generation_constants for more information

    @return a JSON string in UTF-8 encoding representing the JSON-RPC request

    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @par Example:
    @code string json = make_jsonrpc_request("omq.system.help", "1.0", id, msg); @endcode

    @since
    - json 1.5 added this function as a replacement for deprecated camel-case makeJSONRPCRequestString() and makeFormattedJSONRPCRequestString()
    - json 1.7 added support for JSON-RPC 2.0 and corrections for JSON-RPC 1.0 support

    @note do not use the \c version argument for strict JSON-RPC 1.0 compatibility (send as @ref nothing "NOTHING")

    @see
    - @ref jsonserialization
    - @ref JSONRPC
 */
string make_jsonrpc_request(string method_name, any version, any id, any request_msg, *int format) [flags=RET_VALUE_ONLY] {
   if (!version.isNullOrNothing()) {
      QoreStringValueHelper vstr(version, QCS_UTF8, xsink);
      if (*xsink)
         return QoreValue();
      if (**vstr != "1.0")
         return make_jsonrpc_request(method_name, (**vstr)[0] == '1' ? "version" : "jsonrpc", vstr->c_str(), id, request_msg, format, xsink);
   }

   return make_jsonrpc_request(method_name, nullptr, nullptr, id, request_msg, format, xsink);
}

//! Creates a JSON-RPC request string from the parameters passed, without any line breaks
/** To follow JSON-RPC specifications, the generated string will always be in UTF-8 encoding
    @param method_name the name of the JSON-RPC method to call
    @param version the JSON-RPC version to include in the call under the \c "version" key (for JSON-RPC earlier than 2.0) or the \c "jsonrpc" key (for JSON-RPC equal to or greater than 2.0); will be converted to a string; if the resulting string is empty, the \c "version" key will not be sent; for strict JSON-RPC 1.0 compatibility this argument will not be serialized if passed as \c "1.0"
    @param id the ID of the call
    @param request_msg the parameters for the message/message payload

    @return a JSON string in UTF-8 encoding representing the JSON-RPC request

    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @deprecated use make_jsonrpc_request(); camel-case function names were deprecated in json 1.5

    @note do not use the \c version argument for strict JSON-RPC 1.0 compatibility (send as @ref nothing "NOTHING")

    @see
    - @ref jsonserialization
    - @ref JSONRPC
 */
string makeJSONRPCRequestString(string method_name, any version, any id, any request_msg) [flags=RET_VALUE_ONLY,DEPRECATED] {
   if (!version.isNullOrNothing()) {
      QoreStringValueHelper vstr(version, QCS_UTF8, xsink);
      if (*xsink)
         return QoreValue();

      if (**vstr != "1.0")
         return make_jsonrpc_request(method_name, (**vstr)[0] == '1' ? "version" : "jsonrpc", vstr->c_str(), id, request_msg, JGF_NONE, xsink);
   }

   return make_jsonrpc_request(method_name, nullptr, nullptr, id, request_msg, JGF_NONE, xsink);
}

//! Creates a JSON-RPC request string from the parameters passed, formatted with line breaks for easier readability
/** To follow JSON-RPC specifications, the generated string will always be in UTF-8 encoding
    @param method_name the name of the JSON-RPC method to call
    @param version the JSON-RPC version to include in the call under the \c "version" key (for JSON-RPC earlier than 2.0) or the \c "jsonrpc" key (for JSON-RPC equal to or greater than 2.0); will be converted to a string; if the resulting string is empty, the \c "version" key will not be sent; note that for strict JSON-RPC 1.0 compatibility this argument will not be serialized if passed as \c "1.0"s
    @param id the ID of the call
    @param request_msg the parameters for the message/message payload

    @return a JSON string in UTF-8 encoding representing the JSON-RPC request, formatted with line breaks for easier readability

    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @deprecated use make_jsonrpc_request(); camel-case function names were deprecated in json 1.5

    @note do not use the \c version argument for strict JSON-RPC 1.0 compatibility (send as @ref nothing "NOTHING")

    @see
    - @ref jsonserialization
    - @ref JSONRPC
 */
string makeFormattedJSONRPCRequestString(string method_name, any version, any id, any request_msg) [flags=RET_VALUE_ONLY,DEPRECATED] {
   if (!version.isNullOrNothing()) {
      QoreStringValueHelper vstr(version, QCS_UTF8, xsink);
      if (*xsink)
         return QoreValue();

      if (**vstr != "1.0")
         return make_jsonrpc_request(method_name, (**vstr)[0] == '1' ? "version" : "jsonrpc", vstr->c_str(), id, request_msg, JGF_ADD_FORMATTING, xsink);
   }

   return make_jsonrpc_request(method_name, nullptr, nullptr, id, request_msg, JGF_ADD_FORMATTING, xsink);
}

//! Creates a JSON-RPC response string from the parameters passed, without any line breaks
/** @param version the JSON-RPC version to include in the call under the \c "version" key (for JSON-RPC earlier than 2.0) or the \c "jsonrpc" key (for JSON-RPC equal to or greater than 2.0); will be converted to a string; if the resulting string is empty, the \c "version" key will not be sent; note that for strict JSON-RPC 1.0 compatibility this argument will not be serialized if passed as \c "1.0"
    @param id the ID of the call
    @param response_msg the parameters for the message/message payload
    @param format optional formatting flags; see @ref json_generation_constants for more information

    @return a JSON string in UTF-8 encoding representing the JSON-RPC response, without any line breaks

    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @par Example:
    @code string json = make_jsonrpc_response("1.0", id, msg); @endcode

    @since
    - json 1.5 added this function as a replacement for deprecated camel-case makeJSONRPCResponseString() and makeFormattedJSONRPCResponseString()
    - json 1.7 added support for JSON-RPC 2.0 and corrections for JSON-RPC 1.0 support

    @note do not use the \c version argument for strict JSON-RPC 1.0 compatibility (send as @ref nothing "NOTHING")

    @see
    - @ref jsonserialization
    - @ref JSONRPC
 */
string make_jsonrpc_response(any version, any id, any response_msg, *int format) [flags=RET_VALUE_ONLY] {
   if (!version.isNullOrNothing()) {
      QoreStringValueHelper vstr(version, QCS_UTF8, xsink);
      if (*xsink)
         return QoreValue();

      if (**vstr != "1.0")
         return make_jsonrpc_response(xsink, (**vstr)[0] == '1' ? "version" : "jsonrpc", vstr->c_str(), id, response_msg, "result", format);
   }

   return make_jsonrpc_response(xsink, nullptr, nullptr, id, response_msg, "result", format);
}

//! Creates a JSON-RPC response string from the parameters passed, without any line breaks
/** @param version the JSON-RPC version to include in the call under the \c "version" key (for JSON-RPC earlier than 2.0) or the \c "jsonrpc" key (for JSON-RPC equal to or greater than 2.0); will be converted to a string; if the resulting string is empty, the \c "version" key will not be sent; note that for strict JSON-RPC 1.0 compatibility this argument will not be serialized if passed as \c "1.0"
    @param id the ID of the call
    @param response_msg the parameters for the message/message payload

    @return a JSON string in UTF-8 encoding representing the JSON-RPC response, without any line breaks

    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @deprecated use make_jsonrpc_response(); camel-case function names were deprecated in json 1.5

    @note do not use the \c version argument for strict JSON-RPC 1.0 compatibility (send as @ref nothing "NOTHING")

    @see
    - @ref jsonserialization
    - @ref JSONRPC
 */
string makeJSONRPCResponseString(any version, any id, any response_msg) [flags=RET_VALUE_ONLY,DEPRECATED] {
   if (!version.isNullOrNothing()) {
      QoreStringValueHelper vstr(version, QCS_UTF8, xsink);
      if (*xsink)
         return QoreValue();

      if (**vstr != "1.0")
         return make_jsonrpc_response(xsink, (**vstr)[0] == '1' ? "version" : "jsonrpc", vstr->c_str(), id, response_msg, "result", 0);
   }

   return make_jsonrpc_response(xsink, nullptr, nullptr, id, response_msg, "result", 0);
}

//! Creates a JSON-RPC response string from the parameters passed, formatted with line breaks for easier readability
/** @param version the JSON-RPC version to include in the call under the \c "version" key (for JSON-RPC earlier than 2.0) or the \c "jsonrpc" key (for JSON-RPC equal to or greater than 2.0); will be converted to a string; if the resulting string is empty, the \c "version" key will not be sent; note that for strict JSON-RPC 1.0 compatibility this argument will not be serialized if passed as \c "1.0"
    @param id the ID of the call
    @param response_msg the parameters for the message/message payload

    @return a JSON string in UTF-8 encoding representing the JSON-RPC response, formatted with line breaks for easier readability

    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @deprecated use make_jsonrpc_response(); camel-case function names were deprecated in json 1.5

    @note do not use the \c version argument for strict JSON-RPC 1.0 compatibility (send as @ref nothing "NOTHING")

    @see
    - @ref jsonserialization
    - @ref JSONRPC
 */
string makeFormattedJSONRPCResponseString(any version, any id, any response_msg) [flags=RET_VALUE_ONLY,DEPRECATED] {
   if (!version.isNullOrNothing()) {
      QoreStringValueHelper vstr(version, QCS_UTF8, xsink);
      if (*xsink)
         return QoreValue();

      if (**vstr != "1.0")
         return make_jsonrpc_response(xsink, (**vstr)[0] == '1' ? "version" : "jsonrpc", vstr->c_str(), id, response_msg, "result", JGF_ADD_FORMATTING);
   }

   return make_jsonrpc_response(xsink, nullptr, nullptr, id, response_msg, "result", JGF_ADD_FORMATTING);
}

//! Creates a generic JSON-RPC error response string from the parameters passed, without any line breaks
/** @param version the JSON-RPC version to include in the call under the \c "version" key (for JSON-RPC earlier than 2.0) or the \c "jsonrpc" key (for JSON-RPC equal to or greater than 2.0); will be converted to a string; if the resulting string is empty, the \c "version" key will not be sent; note that for strict JSON-RPC 1.0 compatibility this argument will not be serialized if passed as \c "1.0"
    @param id the ID of the call
    @param error_msg the parameters for the error response message/message payload
    @param format optional formatting flags; see @ref json_generation_constants for more information

    @return a JSON string in UTF-8 encoding representing the JSON-RPC error response, without any line breaks

    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @par Example:
    @code string json = make_jsonrpc_error("1.0", id, error); @endcode

    @since
    - json 1.5 added this function as a replacement for deprecated camel-case makeJSONRPCErrorString() and makeFormattedJSONRPCErrorString()
    - json 1.7 added support for JSON-RPC 2.0 and corrections for JSON-RPC 1.0 support

    @note do not use the \c version argument for strict JSON-RPC 1.0 compatibility (send as @ref nothing "NOTHING")

    @see
    - @ref jsonserialization
    - @ref JSONRPC
 */
string make_jsonrpc_error(any version, any id, any error_msg, *int format) [flags=RET_VALUE_ONLY] {
   if (!version.isNullOrNothing()) {
      QoreStringValueHelper vstr(version, QCS_UTF8, xsink);
      if (*xsink)
         return QoreValue();

      if (**vstr != "1.0")
         return make_jsonrpc_response(xsink, (**vstr)[0] == '1' ? "version" : "jsonrpc", vstr->c_str(), id, error_msg, "error", format);
   }

   return make_jsonrpc_response(xsink, nullptr, nullptr, id, error_msg, "error", format);
}

//! Creates a generic JSON-RPC error response string from the parameters passed, without any line breaks
/** @param version the JSON-RPC version to include in the call under the \c "version" key (for JSON-RPC earlier than 2.0) or the \c "jsonrpc" key (for JSON-RPC equal to or greater than 2.0); will be converted to a string; if the resulting string is empty, the \c "version" key will not be sent; note that for strict JSON-RPC 1.0 compatibility this argument will not be serialized if passed as \c "1.0"
    @param id the ID of the call
    @param error_msg the parameters for the error response message/message payload

    @return a JSON string in UTF-8 encoding representing the JSON-RPC error response, without any line breaks

    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @deprecated use make_jsonrpc_error(); camel-case function names were deprecated in json 1.5

    @note do not use the \c version argument for strict JSON-RPC 1.0 compatibility (send as @ref nothing "NOTHING")

    @see
    - @ref jsonserialization
    - @ref JSONRPC
 */
string makeJSONRPCErrorString(any version, any id, any error_msg) [flags=RET_VALUE_ONLY,DEPRECATED] {
   if (!version.isNullOrNothing()) {
      QoreStringValueHelper vstr(version, QCS_UTF8, xsink);
      if (*xsink)
         return QoreValue();

      if (**vstr != "1.0")
         return make_jsonrpc_response(xsink, (**vstr)[0] == '1' ? "version" : "jsonrpc", vstr->c_str(), id, error_msg, "error", 0);
   }

   return make_jsonrpc_response(xsink, nullptr, nullptr, id, error_msg, "error", 0);
}

//! Creates a generic JSON-RPC error response string from the parameters passed, formatted with line breaks for easier readability
/** @param version the JSON-RPC version to include in the call under the \c "version" key (for JSON-RPC earlier than 2.0) or the \c "jsonrpc" key (for JSON-RPC equal to or greater than 2.0); will be converted to a string; if the resulting string is empty, the \c "version" key will not be sent; note that for strict JSON-RPC 1.0 compatibility this argument will not be serialized if passed as \c "1.0"
    @param id the ID of the call
    @param error_msg the parameters for the error response message/message payload

    @return a JSON string in UTF-8 encoding representing the JSON-RPC error response, formatted with line breaks for easier readability

    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @deprecated use make_jsonrpc_error(); camel-case function names were deprecated in json 1.5

    @note do not use the \c version argument for strict JSON-RPC 1.0 compatibility (send as @ref nothing "NOTHING")

    @see
    - @ref jsonserialization
    - @ref JSONRPC
 */
string makeFormattedJSONRPCErrorString(any version, any id, any error_msg) [flags=RET_VALUE_ONLY,DEPRECATED] {
   if (!version.isNullOrNothing()) {
      QoreStringValueHelper vstr(version, QCS_UTF8, xsink);
      if (*xsink)
         return QoreValue();

      if (**vstr != "1.0")
         return make_jsonrpc_response(xsink, (**vstr)[0] == '1' ? "version" : "jsonrpc", vstr->c_str(), id, error_msg, "error", JGF_ADD_FORMATTING);
   }

   return make_jsonrpc_response(xsink, nullptr, nullptr, id, error_msg, "error", JGF_ADD_FORMATTING);
}

//! Creates a JSON-RPC 1.1 error response string from the parameters passed, without any line breaks
/** @param code the error code to return
    @param error a string error message
    @param id the ID of the call
    @param error_msg the parameters for the error response message/message payload
    @param format optional formatting flags; see @ref json_generation_constants for more information

    @return a JSON string in UTF-8 encoding representing the JSON-RPC 1.1 error response, without any line breaks

    @throw MAKE-JSONRPC11-ERROR-STRING-ERROR the error code is not between 100-999 or empty error message string
    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @par Example:
    @code string json = make_jsonrpc11_error(200, msg, id, error); @endcode

    @since json 1.5 as a replacement for deprecated camel-case makeJSONRPC11ErrorString() and makeFormattedJSONRPC11ErrorString()

    @deprecated do not use; support for the non-published JSON-RPC 1.1 protocol was dropped in json 1.7

    @see
    - @ref jsonserialization
    - @ref JSONRPC
 */
string make_jsonrpc11_error(softint code, string error, any id, any error_msg, *int format) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_jsonrpc11_error(code, error, id, error_msg, format, xsink);
}

//! Creates a JSON-RPC 1.1 error response string from the parameters passed, without any line breaks
/** @param code the error code to return
    @param error a string error message
    @param id the ID of the call
    @param error_msg the parameters for the error response message/message payload

    @return a JSON string in UTF-8 encoding representing the JSON-RPC 1.1 error response, without any line breaks

    @throw MAKE-JSONRPC11-ERROR-STRING-ERROR the error code is not between 100-999 or empty error message string
    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @deprecated do not use; camel-case function names were deprecated in json 1.5, and support for the non-published JSON-RPC 1.1 protocol was dropped in json 1.7

    @see
    - @ref jsonserialization
    - @ref JSONRPC
 */
string makeJSONRPC11ErrorString(softint code, string error, any id, any error_msg) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_jsonrpc11_error(code, error, id, error_msg, 0, xsink);
}

//! Creates a JSON-RPC 1.1 error response string from the parameters passed, formatted with line breaks for easier readability
/** @param code the error code to return
    @param error a string error message
    @param id the ID of the call
    @param error_msg the parameters for the error response message/message payload

    @return a JSON string in UTF-8 encoding representing the JSON-RPC 1.1 error response, formatted with line breaks for easier readability

    @throw MAKE-JSONRPC11-ERROR-STRING-ERROR the error code is not between 100-999 or empty error message string
    @throw JSON-SERIALIZATION-ERROR cannot serialize value passed (ex: binary, object)

    @deprecated do not use; camel-case function names were deprecated in json 1.5, and support for the non-published JSON-RPC 1.1 protocol was dropped in json 1.7

    @see
    - @ref jsonserialization
    - @ref JSONRPC
 */
string makeFormattedJSONRPC11ErrorString(softint code, string error, any id, any error_msg) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_jsonrpc11_error(code, error, id, error_msg, JGF_ADD_FORMATTING, xsink);
}
//@}
